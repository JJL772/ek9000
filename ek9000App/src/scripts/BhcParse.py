#!/usr/bin/python3
# Parses a file lol
#
import sys, os, io
import CppTk, EpicsTk
import json, argparse, datetime

"""

JSON SYNTAX:


{
	"name": "EL3202",		// Name of the terminal
	"type": "AnalogIn",		// Type AnalogIn, AnalogOut, DigIn, DigOut
	"inputs": 2,			// Number of input channels
	"outputs": 0,			// Number of output channels
	"pdo_in_size": 4,		// PDO input size. For Digital terminals, this is COILS. For Analog terms, this is REGISTERS (16-bits per reg)  
	"pdo_out_size": 0		// PDO output size. Same rules as in_size.
},

"""

parser = argparse.ArgumentParser(description="Generates a header containing information about each individual terminal")
parser.add_argument("file", metavar="file", type=str, nargs=1, help="The file to parse for terminal info")
parser.add_argument("--output", "-o", dest="output", action='store', type=str, help="The name of the output header")
parser.add_argument("--verify", dest="verify", action="store_const", const=1, help="Verify the json too.")
parser.add_argument("--verbose", dest="verbose", action='store_true', help='Run with extra debug inf')
args = parser.parse_args()

#
# Files are in json format, check them out to figure out the actual syntax
#
file = args.file[0]
if not file or not os.path.exists(file):
	print("ERROR: Could not find input file.")
	sys.exit(1)

out = args.output
json_stuff = None
try:
	print("Parsing " + file)
	with open(file, "r") as fs:
		json_stuff = json.loads(fs.read())
except Exception as e:
	print("Error while parsing json:")
	print(str(e))
	sys.exit(1)

# Make a file to log the supported terminals in
fp = open("../../../SupportedDevices.md", "w")
fp.write("## Supported Devices\n\n")

#
# Header generation 
#
header = CppTk.Header(out)
header.add_block_comment("\nAUTOGENERATED FILE: DO NOT EDIT.\n")
header.fs.write("#pragma once\n\n")
header.include_std("stddef.h")
header.include_std("stdint.h")
header.newline()
header.begin_struct("terminal_s")
header.add_variable("m_pString", "const char*")
header.add_variable("m_nID", "uint32_t")
header.add_variable("m_nOutputSize", "uint16_t")
header.add_variable("m_nInputSize", "uint16_t")
header.end_struct()
header.add_typedef("terminal_t", "terminal_s")
header.add_typedef("STerminalInfoConst_t", "terminal_t")
header.newlines(3)

try:
	count = 0
	vars = list()
	for terminal in json_stuff["terminals"]:
		count = count + 1
		name = terminal["name"]
		fp.write("* " + name)
		fp.write("\n")
		vars.append("&" + name + "_Info")
		outsize = terminal["pdo_out_size"]
		insize = terminal["pdo_in_size"]
		header.add_block_comment(name)
		header.add_define(name + "_STRING", '"' + name + '"')
		header.add_define(name + "_ID", name.replace("EL", ""))
		header.add_define(name + "_OUTPUT_SIZE", str(outsize))
		header.add_define(name + "_INPUT_SIZE", str(insize))
		header.add_init_struct("STerminalInfoConst_t", name + "_Info", name + "_STRING", name + "_ID",
			name + "_OUTPUT_SIZE", name + "_INPUT_SIZE", static=True, const=True)
	header.newlines(1)
	header.add_define("NUM_TERMINALS", str(count))
	header.newlines(1)
	header.add_array_variable("g_pTerminalInfos", "STerminalInfoConst_t*", vars, const=True, static=True)
except KeyError as e:
	print("Malformed JSON:")
	print("\tMissing the array key 'terminals'.")

fp.close()

#
# Template/subs generation
#
bi_record_template = \
"""
record(bi,"$(TERMINAL):$$NUM")
{
        field(DESC,  "")
        field(DTYP,  "EL10XX")
        field(ZNAM,  "low")
        field(ONAM,  "high")
        field(SCAN,  ".1 second")
        field(PINI,  "YES")
}
"""

bo_record_template =\
"""
record(bo,"$(TERMINAL):$$NUM")
{
        field(DESC,  "")
        field(DTYP,  "EL20XX")
        field(ZNAM,  "low")
        field(ONAM,  "high")
        field(PINI,  "YES")
}
"""

ai_record_template = \
"""
record(ai,"$(TERMINAL):$$NUM")
{
        field(DESC,  "")
        field(DTYP,  "EL30XX")
        field(SCAN,  ".1 second")
        field(EGU,   "Volts")
        field(LINR,  "LINEAR")
        field(PINI,  "YES")
}
"""

ao_record_template = \
"""
record(ao,"$(TERMINAL):$$NUM")
{
        field(DESC,  "")
        field(DTYP,  "EL40XX")
        field(SCAN,  ".1 second")
        field(LINR,  "LINEAR")
        field(PINI,  "YES")
}
"""

subs = \
"""
file $$FILE
{       pattern
        {
                TERMINAL,

        }
        {
        }
}
"""

with open("../../Db/Templates.mak", "w") as fp:
	print("Writing Templates.mak")
	fp.write("\n# AUTOGENERATED FILE, DO NOT EDIT\n\n")
	for terminal in json_stuff["terminals"]:
		template_filename = '../../Db/' + terminal["name"] + ".template"
		subs_filename = '../../Db/' + terminal["name"] + ".substitutions"
		name = terminal["name"]
		inputs = terminal["inputs"]
		outputs = terminal["outputs"]
		tfp = open(template_filename, "w")
		sfp = open(subs_filename, "w")
		if terminal["type"] == "DigIn":
			for i in range(inputs):
				tfp.write(bi_record_template.replace("$$NUM", str(i+1)))
				tfp.write("\n\n")
		elif terminal["type"] == "DigOut":
			for i in range(inputs):
				tfp.write(bo_record_template.replace("$$NUM", str(i+1)))
				tfp.write("\n\n")
		elif terminal["type"] == "AnalogIn":
			for i in range(inputs):
				tfp.write(ai_record_template.replace("$$NUM", str(i+1)))
				tfp.write("\n\n")
		elif terminal["type"] == "AnalogOut":
			for i in range(outputs):
				tfp.write(ao_record_template.replace("$$NUM", str(i+1)))
				tfp.write("\n\n")
		# Both in and out
		elif terminal["type"] == "AnalogIO":
			for i in range(inputs):
				tfp.write(ai_record_template.replace("$$NUM", str(i+1)))
				tfp.write("\n\n")
			for i in range(outputs):
				tfp.write(ao_record_template.replace("$$NUM", str(i+1)))
				tfp.write("\n\n")
		# Write out the subs
		sfp.write(subs.replace("$$FILE", name + ".template"))
		fp.write("# {2} \nDB += {0} {1}\n\n".format(name + ".template", name + ".substitutions", name))
		tfp.close()
		sfp.close()
		if args.verbose:
			print("Wrote {0} and {1} (had {2} inputs and {3} outputs)".format(template_filename, subs_filename,
				inputs, outputs))
	fp.write("\n\n")
